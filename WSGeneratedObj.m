/*-
 * WSGeneratedObj.m
 *
 *	Version 0.11
 *
 * This class was automatically generated by WSMakeStubs, part of the
 * WebServicesCore framework.
 * It implements a generic object layer on top of the primitive WebServicesCore API.
 *
 */

#include "WSGeneratedObj.h"
#import <libkern/OSAtomic.h>

@implementation WSGeneratedObj

- (id) init
{
	if ((self = [super init]) != NULL) {
		fRef = NULL;
		fResult = NULL;
        cancelled = NO;
	}
	return self;
}

- (void) dealloc
{
	if (fRef) {
		CFRelease(fRef);
		fRef = NULL;
	}
	[fResult release];
	fResult = NULL;
	[super dealloc];
}

	// Return (possibly creating) the WSMethodInvocationRef
- (WSMethodInvocationRef) getRef
{
	if (fRef == NULL)
		fRef = [self genCreateInvocationRef];
	return fRef;
}

- (void) cancel;
{
    OSAtomicCompareAndSwap32Barrier(0, 1, &cancelled);
}

	// Return the Result object.  If it hasn't
	// been fetched yet, this will asynchronously block
- (NSDictionary*) getResultDictionary
{
    if (NULL == fResult) {
        
        CFRunLoopRef rl = CFRunLoopGetCurrent();
        
        // Use a private runloop mode for the async callback and block until it returns or we are cancelled; this allows class methods to block for compatibility, but instances can be cancelled.
        CFStringRef mode = CFSTR("WSGeneratedObj-sync");
        
        WSMethodInvocationRef invocation = [self getRef];
        WSMethodInvocationScheduleWithRunLoop(invocation, rl, mode);
        
        do {
            
            SInt32 res = CFRunLoopRunInMode(mode, 0.1, TRUE);
            if (kCFRunLoopRunStopped == res || kCFRunLoopRunFinished == res)
                break;
            
            OSMemoryBarrier();
            
        } while (0 == cancelled && NULL == fResult);
        
        WSMethodInvocationUnscheduleFromRunLoop(fRef, rl, mode);
    }
    
    if (fResult == NULL && 0 == cancelled) {
        [self handleError:@"WSMethodInvocationInvoke failed in getResultDictionary" errorString:NULL errorDomain:kCFStreamErrorDomainMacOSStatus errorNumber:paramErr];
    }
	return fResult;
}

	// Returns true if the Result is a fault
- (BOOL) isFault
{
	NSDictionary* rr = [self getResultDictionary];
	if (rr == NULL)
		return false;
	return WSMethodResultIsFault((CFDictionaryRef) rr);
}

	// Check if the invocation is complete - that is,
	// if it will not re-issue the request to get the result.
- (BOOL) isComplete
{
	return fResult != NULL;
}

	// Returns the return Value associated with this method.
- (id) getValue
{
	return [[self getResultDictionary] objectForKey: (id) kWSMethodInvocationResult];
}


- (void) handleError:(NSString*) stubError errorString:(NSString*) errorString errorDomain:(int) errorDomain errorNumber:(int) errorNumber
{
	NSLog(@"WSGeneratedObj handleError:\n	-> %@\n	-> %@\n	-> %d / %d", stubError, errorString, errorDomain, errorNumber);
}

	// Utility function to set the parameter list for the invocation
- (void) setParameters:(int) count values:(id*) values names:(NSString**) names
{
	NSDictionary* params = [NSDictionary dictionaryWithObjects:values forKeys: names count: count];
	NSArray* paramOrder = [NSArray arrayWithObjects: names count: count];
	WSMethodInvocationSetParameters([self getRef], (CFDictionaryRef) params, (CFArrayRef) paramOrder);
}

- (NSDictionary*) copyHeaderDictionary:(int) count extraVals: (NSString**) extraVals extraKeys: (NSString**) extraKeys
{
	return [[NSDictionary dictionaryWithObjects:extraVals forKeys: extraKeys count: count] retain];
}

static void invocationFinished(WSMethodInvocationRef invocation, void *info, CFDictionaryRef outRef)
{
    WSGeneratedObj *service = info;
    NSCParameterAssert(NULL == service->fResult);
    service->fResult = (NSDictionary *)outRef;
}

	// Utility function called by the generated code to create the invocation
- (WSMethodInvocationRef) createInvocationRef:(NSString*) endpoint
								   methodName:(NSString*) methodName
								   protocol:(NSString*) protocol
										style:(NSString*) style
								   soapAction:(NSString*) soapAction
							  methodNamespace:(NSString*) methodNamespace
{
	WSMethodInvocationRef ref = NULL;
	NSURL* url = [NSURL URLWithString: endpoint];
	if (url == NULL) {
		[self handleError: @"NSURL URLWithString failed in createInvocationRef" errorString:NULL errorDomain:kCFStreamErrorDomainMacOSStatus errorNumber: paramErr];
	} else {
		ref = WSMethodInvocationCreate((CFURLRef) url, (CFStringRef) methodName, (CFStringRef) protocol);
		
		if (ref == NULL)
			[self handleError: @"WSMethodInvocationCreate failed in createInvocationRef" errorString:NULL errorDomain:kCFStreamErrorDomainMacOSStatus errorNumber: paramErr];
		else {
			WSMethodInvocationSetProperty(ref, kWSSOAPBodyEncodingStyle, style);

			NSString* soapActionKey = @"SOAPAction";
			NSDictionary* headers = [self copyHeaderDictionary:1 extraVals:&soapAction extraKeys:&soapActionKey];
			WSMethodInvocationSetProperty(ref, kWSHTTPExtraHeaders, headers);
			[headers release];

			WSMethodInvocationSetProperty(ref, kWSSOAPMethodNamespaceURI, methodNamespace);
            
            WSClientContext ctxt = { 0, 
                                    (void *)self, 
                                    (WSClientContextRetainCallBackProcPtr)CFRetain, 
                                    (WSClientContextReleaseCallBackProcPtr)CFRelease, 
                                    (WSClientContextCopyDescriptionCallBackProcPtr)CFCopyDescription };
            WSMethodInvocationSetCallBack(ref, invocationFinished, &ctxt);
		}
	}
	
	return ref;
}

	// Must be implemented by client
- (WSMethodInvocationRef) genCreateInvocationRef
{
	return NULL;
}

@end

